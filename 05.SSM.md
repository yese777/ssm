框架:软件的半成品.为解决问题制定的一套约束,在提供功能基础上进行扩充.

框架中一些不能被封装的代码(变量),需要框架使用者新建一个xml 文件,在文件中添加变量内容.

# 1.Mybatis

https://github.com/yese777/Mybatis

中文文档: https://mybatis.org/mybatis-3/zh/index.html 

开源免费

- MyBatis 是ORM**持久层**框架，

- 它支持定制化 SQL、动态SQL,存储过程以及高级映射。

- 封装了jdbc的操作

- MyBatis 可以使用 XML 或注解来配置

## 1.1.架构图

![](https://studypic.oss-cn-shanghai.aliyuncs.com/pic/1563949966604.png)

##   1.2.运行原理

先通过 Resources 加载全局配置文件,实例化SqlSessionFactoryBuilder,解析xml配置文件,获得所有的配置信息,然后SqlSessionFactoryBuilder创建 SqlSessionFactory 工厂,由 SqlSessionFactory 工厂创建 SqlSession.每次创建 SqlSession 时,都需要创建Transaction对象和 Excutor执行器,Excutor执行CRUD,借助MappedStatement对返回结果进行封装,如果执行失败,回滚事务.执行成功提交事务.最后关闭 SqlSession

## 1.3.接口动态代理

创建一个接口后,由mybatis把mapper.xml生成接口的实现类,通过调用接口对象就可以获取 mapper.xml 中编写

的 sql. 

官方推荐使用接口动态代理的方式

typeAliases 别名:直接给某个包下所有类起别名,别名为类名, 不区分大小写

## 1.4.Mapper.java 和Mapper.xml

### 1.4.1.获取参数

注意：为了安全，能用#{}的地方就用#{}方式传参，这样可以有效的防止sql注入

####  #{} 和 ${} 的区别

#{}是预编译处理，$ {}是字符串替换。

mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；

mybatis在处理 $ { } 时，就是把 ${ } 替换成变量的值。使用 #{} 可以有效的防止SQL注入，提高系统安全性。但是表名用参数传递进来的时候，只能使用 ${}。MyBatis排序时使用order by 动态参数时需要注意，用$而不是#

#### 1.@Param

@Param("")指定参数名

#### 2.pojo对象

入参是pojo对象,使用#{属性名}

#### 3.map(常用)

参数是 map ,使用#{key}(实际开发中常用)

UserMapper.java

```java
List<User> getUser(HashMap<String, Object> map);
```

前面传过来的map

```java
Map<String, Object> map = new HashMap<>();
map.put("id","1");
map.put("age",12);
```

UserMapper.xml

```xml
<select id="getUser" parameterType="map" resultType="user">
    select * from T_SYS_USER t where t.id = #{id} and t.age = #{age}
</select>
```

#### 4.索引

使用索引,从 0 开始 #{0}表示第一个参数,严格按照参数顺序来引用

UserMapper.java

```java
User getUserById(String id);
```

UserMapper.xml

```xml
<select id="getUserById" parameterType="string" resultType="user">
	select * from T_SYS_USER t where t.id = #{0}
</select>
```

#### 5.#{param1}

使用#{param1}表示第一个参数,依次类推,严格按照参数顺序来引用

UserMapper.java

```java
User getUserByNameAndPwd(String username,String password);
```

UserMapper.xml

```xml
<!-- 如果接口中方法为多个参数时,不需要写 parameterType -->
<select id="getUserByNameAndPwd" resultType="user">
    select * from T_SYS_USER t where t.username = #{param1} and t.password=#{param2}
</select>
```

#### 6.只有一个参数

如果只有一个参数(基本数据类型或 String),mybatis对#{}里面内容没有要求只要写内容即可

UserMapper.java

```java
User getUserById(String id);
```

UserMapper.xml

```xml
<select id="getUserById" parameterType="string" resultType="user">
    只能够使用 #{} 来取参数，而不能够直接使用 ${} 来取参数，否则会报错
    select * from T_SYS_USER t where t.id = #{aaa}
</select>
```

#### 7.pojo包装对象

传递pojo包装对象

(QueryVo)

包装的pojo取值通过 "pojo.属性"来获取

实体

```java
public class QueryVo {
	private User user;
    //提供get/set
}
```

UserMapper.java

```java
List<User> getUser(QueryVo qv);
```

UserMapper.xml

```xml
<select id="getUser" parameterType="queryvo" resultType="user">
	select * from T_SYS_USER t where t.id = #{user.id}
</select>
```



还有可以获取参数的其他方式,可以参考

https://blog.csdn.net/bdqx_007/article/details/94836637

### 1.4.2.接口绑定开发规则

1.	namespace必需是Dao/Mapper接口的全路径名
2.	接口的方法名必需与映射文件的sql 标签的 id一致
3.	接口的输入参数必需与映射文件的parameterType类型一致
4.	接口的返回值类型必须与映射文件的resultType类型一致

注意:

- 如果方法返回值是 list,在 resultType 中写 List 的泛型,因为 mybatis是对jdbc的封装,一行一行读取数据
- 如果接口中方法为多个参数时,不需要写 parameterType
- mybatis 中<insert> <delete> <update>标签没有 resultType 属性,认为返回值都是 int,表示受影响的行数

  

### 1.4.3.增

对象从前面赋值传进来

UserMapper.java

```java
    int insertUser(User user);
```

UserMapper.xml

```xml
    <insert id="insertUser" parameterType="user">
        insert into T_SYS_USER values (#{id},#{username},#{password},#{age},#{birthday});
    </insert>
```

### 1.4.4.改

UserMapper.java

```java
    int updateUser(User user);
```

UserMapper.xml

```xml
    <update id="updateUser" parameterType="user">
        update T_SYS_USER t set t.username = #{username} where t.id = #{id}
    </update>
```

### 1.4.5.删

UserMapper.java

```java
    int deleteUser(@Param("id") String id);
```

UserMapper.xml

```xml
    <delete id="deleteUser" parameterType="string">
        delete from T_SYS_USER t WHERE t.id = #{id}
    </delete>
```

### 1.4.6.查

#### 查一个

UserMapper.java

```java
    User getUserById(@Param("id") String id);
```

UserMapper.xml

```xml
    <select id="getUserById" parameterType="string" resultType="user">
        select * from T_SYS_USER t where t.id = #{id}
    </select>
```

#### 查全部

UserMapper.java

```java
    List<User> getAllUser();
```

UserMapper.xml

```xml
    <select id="getAllUser" resultType="user">
        select * from T_SYS_USER
    </select>
```

#### 模糊查询

UserMapper.java

```java
    // 模糊查询1
    List<User> getUserLike1(@Param("guanJianZi")String guanJianZi);

    // 模糊查询2
    List<User> getUserLike2(User user);
```

UserMapper.xml

```xml
    <select id="getUserLike1" parameterType="string" resultType="user">
        select * from T_SYS_USER t where t.username like "%"#{guanJianZi}"%"
    </select>

    <select id="getUserLike2" parameterType="user" resultType="user">
        select * from T_SYS_USER t where t.username like concat('%',#{username},'%')
    </select>
```

####  mysql 分页

"?"不允许在关键字前后进行数学运算,需要在代码中计算完成后传递到 XxxMapper.xml 中

UserMapper.java

```java
    List<User> getUserWithFy(Map<String, Object> map);
```

前面传过来的map

```java
        Map<String, Object> map = new HashMap<>();
        map.put("pageStart",0);
        map.put("pageSize",2);
```

UserMapper.xml

```xml
    <select id="getUserWithFy" parameterType="map" resultType="user">
        select * from T_SYS_USER t limit #{pageStart},#{pageSize}
    </select>
```



## 1.5.动态 SQL

https://mp.weixin.qq.com/s?__biz=MzI3ODg2OTY1OQ==&mid=2247485527&idx=2&sn=551d46da023750072a4473e23fd7a99e&chksm=eb512ba3dc26a2b580fec2be8dce05ec851335463d5e8aab441b46cb681df02f343ad61f17c6&mpshare=1&scene=24&srcid=#rd

根据不同的条件需要执行不同的 SQL 命令.称为动态 SQL.

MyBatis 中动态 SQL 在 mapper.xml 中添加逻辑判断等.

### 1.5.1.if

UserMapper.java

```java
List<User> getUser(@Param("loginName") String loginName, @Param("loginPassword") String loginPassword);
```

UserMapper.xml

```xml
<select id="getUser" resultType="user">
    select * from T_SYS_USER t where 1=1    
    <!-- OGNL 表达式,直接写 Param 的名称 -->    
    <if test="loginName!=null and loginName!=''">
        and t.loginName=#{loginName}    
    </if>    
    <if test="loginPassword!=null and loginPassword!=''">
        and t.loginPassword=#{loginPassword}    
    </if>
</select>
```

### 1.5.2.where

当编写 where 标签时,如果内容中第一个是 and 去掉第一个and. 如果<where>中有内容会生成 where 关键字,如

果没有内容不生成 where 关键

UserMapper.java

```java
List<User> getUser(@Param("loginName") String loginName, @Param("loginPassword") String loginPassword);
```

UserMapper.xml

```xml
<!-- 比直接使用<if>少写 where 1=1 -->
    <select id="getUser" resultType="user">
        select * from T_SYS_USER t
        <where>
            <if test="loginName!=null and loginName!=''">
                and t.loginName=#{loginName}
            </if>
            <if test="loginPassword!=null and loginPassword!=''">
                and t.loginPassword=#{loginPassword}
            </if>
        </where>
    </select>
```

### 1.5.3.choose

choose (when, otherwise)

相当于switch

1.一旦有条件成立的when，后续的when则不会执行   

2.当所有的when都不执行时,才会执行otherwise 

假设有这样1个需求：当参数id有值时优先使用id查询，当id没有值时就去判断用户名是否有值，如果有值就用用户名查询，如果没值，就使查询无结果。

UserMapper.java

```java
User getUser(User user);
```

UserMapper.xml

```xml
    <select id="getUser" parameterType="user" resultType="user">
        select * from T_SYS_USER t
        <where>
            <choose>
                <when test="id!=null and id!=''">
                    and t.id=#{id}
                </when>
                <when test="loginName!=null and loginName!=''">
                    and t.loginName=#{loginName}
                </when>
                <otherwise>
                    and 1 = 2
                    <!--以上when都不执行时才会执行的sql片段-->
                </otherwise>
            </choose>
        </where>
    </select>
```

### 1.5.4.set

用在update语句中的 set 从句,去掉最后一个逗号,如果<set>里面有内容生成 set 关键字,没有就不生成

 id=#{id} 目的防止<set>中没有内容,mybatis 不生成 set 关键字,如果update语句中没有 set 从句 SQL 语法错误.

UserMapper.java

```java
int updateUser(User user);
```

UserMapper.xml

```xml
    <update id="updateUser" parameterType="user">
        update T_SYS_USER t
        <set>
            t.id=#{id},
            <if test="loginName!=null and loginName!=''">
                t.loginName=#{loginName},
            </if>
            <if test="loginPassword!=null and loginPassword!=''">
                t.loginPassword=#{loginPassword},
            </if>
        </set>
        where t.id=#{id}
    </update>
```

### 1.5.5.trim

一般用于去除sql语句中多余的and关键字，逗号，或者给sql语句前拼接 “where“、“set“以及“values(“ 等前缀，或者添加“)“等后缀，可用于选择性插入、更新、删除或者条件查询等操作。

```
prefix : 给sql语句拼接的前缀 
prefixOverrides 去掉前面内容
suffix : 给sql语句拼接的后缀 
suffixOverrieds 去掉后面内容
```

执行顺序:去掉内容后再添加内容

```xml
    <!--前面加了'set',后面去掉了','-->
    <update id="updateUser" parameterType="user">
        update T_SYS_USER t
        <trim prefix="set" suffixOverrides=",">
            t.loginName=#{loginName},
        </trim>
        where t.id=#{id}
    </update>
```

### 1.5.6.bind

给参数重新赋值,用于模糊查询/在原内容前或后添加内容

```xml
    <!--模糊查询,假设前台穿过来的user对象的username=张三,现在拼接为%张三%来执行模糊查询-->
    <select id="getUser" parameterType="user" resultType="user">
        select * from T_SYS_USER t
        <where>
            <if test="username!=null and username!=''">
                <bind name="aa" value=" '%' + username + '%' "/>
                and t.username like #{aa}
            </if>
        </where>
    </select>
```

### 1.5.7.foreach

循环参数内容,可以在内容的前后添加内容,内容之间添加分隔符

多用于 in  查询

批量新增中(mybatis 中 foreach 效率比较低)建议使用以下命令

```sql
insert into user VALUES (default,"张三",19),(default,"李四",20),(default,"王五",21)
```

```
 collection=” ” 要遍历的集合
 item 迭代变量, #{迭代变量名}获取内容
 open 循环后左侧添加的内容
 close 循环后右侧添加的内容
 separator 每次循环时,元素之间的分隔符
```

```xml
    <!--假设传来的list是{1,2,3},则执行的sql后半部为where id in (1,2,3)-->
    <select id="selectIn" parameterType="list" resultType="user">
        select * from T_SYS_USER t where t.id in
        <foreach collection="list" item="abc" open="(" close=")" separator=",">
            #{abc}
        </foreach>
    </select>
```

### 1.5.8.sql和include

使用<sql>定义某些 复用的SQL 片段

```xml
<sql id="user_column">
	id,username,password
</sql>
```

```xml
<select id="getUser">
    select <include refid="user_column"></include>
    from T_SYS_USER
</select>
```

## 1.6.属性和字段不一致

### 1.6.1.别名

使用别名

```xml
<select id="getUser" resultType="user">
	SELECT
      username,
      login_name AS loginName,
      login_password AS password
    FROM
      T_SYS_USER
</select>
```

### 1.6.2.resultMap 做映射

使用resultMap 做映射

结果集映射

```
<resultMap>标签写在mapper.xml中,由程序员控制SQL查询结果与实体类的映射关系
使用<resultMap>标签时,<select>标签不写 resultType 属性,而是使用 resultMap 属性引用<resultMap>标签.
```

(相同的可以省略不写)

```xml
<!-- property为对象属性, column为列名-->
<resultMap type="user" id="mymap">
    <!-- 主键使用 id 标签配置映射关系 -->
    <id property="id" column="id"/>
    <!-- 其他使用 result 标签配置映射关系 -->
    <result property="username" column="username" /><!--相同-->
    <result property="loginName" column="login_name" /><!--不同-->
    <result property="password" column="login_password"/><!--不同-->
</resultMap>

<select id="getUser" resultMap="mymap"><!--引用上面的resultMap-->
	select * from T_SYS_USER 
</select>
```

### 1.6.3.开启驼峰命名转换

mybatis-config.xml

```xml
<settings>
    <!--其他配置-->
    <setting name="mapUnderscoreToCamelCase" value="true"/>
</settings>
```

## 1.7.简单注解开发

底层实现:反射机制

可以简化mapper.xml 配置文件,如果涉及复杂 SQL 依然可以使用 mapper.xml

mapper.xml 和注解可以共存.

使用注解方式同样需要考虑表字段和Java属性字段映射的问题

查

``` java
@Select("select * from T_SYS_USER")
List<User> getUser();
```

增

```java
@Insert("insert into T_SYS_USER values(#{id},#{username})")
int insertUser(User user);
```

改

```java
@Update("update T_SYS_USER set username=#{username} where id=#{id}")
int updateUser(User user);
```

删

```java
@Delete("delete from T_SYS_USER where id=#{id}")
int deleteUserById(Param("id")int id);
```

## 1.8.多表查询

```java
/**
 * 员工实体
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Emp {

    private String id;

    private String name;

    // 部门 id
    private String deptId;

}
```

```java
/**
 * 部门实体
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Dept {

    private String id;

    private String name;

}
```

```sql
CREATE TABLE `emp` (
  `id` varchar(50)  NOT NULL,
  `name` varchar(50)  NOT NULL,
  `deptId` varchar(50)  NOT NULL,
  PRIMARY KEY (`id`)
) 
```

```sql
CREATE TABLE `dept` (
  `id` varchar(50)  NOT NULL,
  `name` varchar(50)  NOT NULL,
  PRIMARY KEY (`id`)
) 
```

### 1.9.1.一对一查询

查询员工信息,并且查询对应的部门信息 

#### 1.9.1.1.	联合查询

方法1:  面向对象思想

在emp对象中添加dept对象。使用resultMap和 association标签手动完成结果集映射 

```java
/**
 * 员工实体
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Emp {
    private String id;
    private String name;
    // 部门 id
    private String deptId;

    //此处添加Dept对象
    private Dept dept;
}
```

EmpMapper.java

```java
public interface EmpMapper {

    // 查询员工信息及对应的部门信息
    // 1 对 1 查询之联合查询之面向对象思想
    List<Emp> getEmpWithDept1();
}
```

EmpMapper.xml

```xml
    <!-- property为对象属性, column为列名-->
    <resultMap type="emp" id="resultMap1">
        <!-- 主键使用 id 标签配置映射关系 -->
        <id property="id" column="id"/>
        <!-- 其他使用 result 标签配置映射关系 -->
        <result property="name" column="name"/>
        <result property="deptId" column="deptId"/>
        <!-- association:配置子对象的映射
             property:绑定的User属性
             javaType:属性数据类型，支持别名
        -->
        <association property="dept" javaType="com.yese.pojo.Dept">
            <id property="id" column="did"/>
            <result property="name" column="dname"/>
        </association>
    </resultMap>

    <select id="getEmpWithDept1" resultMap="resultMap1">
        select a.id,a.name,a.deptId,b.id did,b.name dname from emp a LEFT JOIN dept b on a.deptId=b.id
    </select>
```



方法2: 扩展对象思想

核心思想扩展emp对象，来完成映射

EmpExtend类继承Emp类后包括了Emp类的所有字段，只需要定义Dept的字段即可(或者直接添加Dept对象)。

(如果Emp和Dept有同名的属性,只要在EmpDept里面重新命名新属性名)

```java
/**
 * 拓展员工实体(只用在1 对 1 查询之联合查询之拓展对象思想)
 * EmpDept类继承Emp类后包括了Emp类的所有字段，只需要定义Dept的字段即可(或者直接添加Dept对象)。
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class EmpExtend extends Emp2 {
    // dept id
    private String did;
    // dept name
    private String dname;
}
```

Emp2Mapper.java

```java
public interface Emp2Mapper {
    List<EmpExtend> getEmpWithDept();
}
```

Emp2Mapper.xml

```xml
    <!--使用别名完成与EmpDept对象的映射-->
    <select id="getEmpWithDept" resultType="EmpExtend">
        select a.id,a.name,a.deptId,b.id did,b.name dname from emp a left join dept b on a.deptId = b.id
    </select>
```

#### 1.9.1.2.	N+1

先查询出某个表的全部信息,根据这个表的信息查询另一个表的信息

```java
/**
 * 员工实体
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Emp {
    private String id;
    private String name;
    // 部门 id
    private String deptId;
    // 此处添加Dept对象
    private Dept dept;

}
```

DeptMapper.java

```java
public interface DeptMapper {
    // 根据 id 查找部门
    List<Dept> getDeptById(@Param("id") String id);
}
```

DeptMapper.xml

```xml
    <select id="getDeptById" parameterType="string" resultType="dept">
        select * from dept where id = #{id}
    </select>
```

EmpMapper.java

```java
public interface EmpMapper {
    // 查询员工信息及对应的部门信息
    // 1 对 1 查询之N+1方式
    List<Emp> getEmpWithDept2();
}
```

EmpMapper.xml

```xml
    <resultMap type="emp" id="resultMap2">
        <id property="id" column="id"/>
        <result property="name" column="name"/>
        <result property="deptId" column="deptId"/>
        <!--
            <association> 装配一个对象时使用
            property: 对象在类中的属性名
            select:通过哪个查询查询出这个对象的信息
            column: 把当前表的哪个列的值做为参数传递给另一个查询
        -->
        <association property="dept" select="com.yese.mapper.DeptMapper.getDeptById" column="deptId" javaType="Dept">
        </association>
    </resultMap>

    <select id="getEmpWithDept2" resultMap="resultMap2">
        select * from emp
    </select>
```

注意:使用 N+1 方式时,如果列名和属性名相同可以不配置,使用 Auto mapping 特性.但是 mybatis 默认只会给列
装配一次,所以association标签用到的column一定要用result标签装配一次



### 1.9.2.联合查询和N+1 方式对比

N+1:需求不确定时.
联合查询:需求中确定查询时两个表一定都查询.



N+1 名称由来
举例:Emp中有 N 条数据,查询所有Emp信息及Dept信息
需要执行1次select * from emp ,执行N 遍 select * from dept where id =  emp的外键
使用多条 SQl 命令查询两表数据时,如果希望把需要的数据都查询出来,需要执行 N+1 条 sql

缺点: 效率低

### 1.9.3.一对多查询

查询老师的所有学生

```java
/**
 * 老师实体(1 的一方)
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Teacher {
    private String id;
    private String name;
    
    //放多的一方的集合
    private List<Student> students;
}
```

```java
/**
 * 学生实体(多的一方)
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Student {
    private String id;
    private String name;
}
```



#### 1.9.3.1.	联合查询

TeacherMapper.java

```java
public interface TeacherMapper {
    // 1 对 多 查询之联合查询
    List<Teacher> getTeacherWithStudent1();
}
```

TeacherMapper.xml

```xml
    <resultMap type="teacher" id="resultMap1">
        <id property="id" column="id" />
        <result property="name" column="name" />
        <!-- collection:用来装配集合
            property属性表示List<B>的变量名
            ofType:property的数据类型，支持别名
        -->
        <collection property="students" ofType="student" >
            <id property="id" column="sid" />
            <result property="name" column="sname" />
        </collection>
    </resultMap>

    <select id="getTeacherWithStudent1"  resultMap="resultMap1">
        select a.id,a.name,b.id sid,b.name sname,b.teacherId from teacher a left join student b on a.id=b.teacherId
    </select>
```

#### 1.9.3.2.	N+1

StudentMapper.java

```java
public interface StudentMapper {
    List<Student> getStudentByTeacherId(@Param("teacherId") String teacherId);
}
```

StudentMapper.xml

```xml
    <select id="getStudentByTeacherId" resultType="student">
        select	* from	student a where	a.teacherId = #{teacherId}
    </select>
```

TeacherMapper.java

```java
public interface TeacherMapper {
    // 1 对 多 查询之N+1
    List<Teacher> getTeacherWithStudent2();
}
```

TeacherMapper.xml

```xml
    <resultMap type="teacher" id="resultMap2">
        <id property="id" column="id"/>
        <result property="name" column="name"/>
        <collection property="students" select="com.yese.mapper.StudentMapper.getStudentByTeacherId" column="id"></collection>
    </resultMap>

    <select id="getTeacherWithStudent2" resultMap="resultMap2">
        select * from teacher
    </select>
```



## 1.9.缓存

存在内存中的临时数据

减少和数据库的交互,减少系统开销,提高系统效率

经常查询且不经常改变的数据可以使用缓存

### 1.10.1.一级缓存

sqlsession级别的缓存,也称本地缓存

一级缓存默认开启(拿到连接到关闭的区间内)

与数据库同一次会话期间查询到的数据会放在本地缓存中,以后如果需要获取相同的数据,直接从缓存中拿,没必要再去查询数据库

增删改操作会改变原来的数据,一定会刷新缓存

### 1.10.2.二级缓存

二级缓存也叫全局缓存,基于namespace

工作机制:

- 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中


- 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中


- 新的会话查询数据，就可以从二级缓存中获取内容；


- 不同的 mapper 査出来的数据会放在自己对应的缓存（map）中



手动开启二级缓存:

- 全局配置文件新增

  ```xml
          <!--显示的开启缓存(默认就是开启的)-->
          <setting name="cacheEnabled" value="true"/>
  ```

- mapper.xml添加

  ```xml
  <cache/>
  如果不写<cache readOnly="true"/>需要实体类实现serializable接口
  ```

### 1.10.3.缓存原理

```
二级缓存开启的情况下,用户的请求先去二级缓存中查
	查到了直接返回数据
	查不到去一级缓存中查
		查到了返回
		查不到就去数据库中查,然后把数据放在一级缓存中.
			如果sqlsession没有关闭,再查就去一级缓存中拿数据
			如果关闭了就会把一级缓存中的数据转移给二级缓存
```

## 1.10.逆向工程

新建一个maven项目

![](https://studypic.oss-cn-shanghai.aliyuncs.com/pic/image-20191213220757151.png)

```xml
    <dependency>
      <groupId>org.mybatis.generator</groupId>
      <artifactId>mybatis-generator-core</artifactId>
      <version>1.3.7</version>
    </dependency>

    <dependency>
      <groupId>log4j</groupId>
      <artifactId>log4j</artifactId>
      <version>1.2.17</version>
    </dependency>
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis</artifactId>
      <version>3.5.3</version>
    </dependency>
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>8.0.18</version>
    </dependency>

    <dependency>
      <groupId>org.mybatis.generator</groupId>
      <artifactId>mybatis-generator</artifactId>
      <version>1.3.7</version>
    </dependency>

    <dependency>
      <groupId>org.mybatis.generator</groupId>
      <artifactId>mybatis-generator-maven-plugin</artifactId>
      <version>1.3.7</version>
    </dependency>
```

generationConfig.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">

<generatorConfiguration>
    <context id="sqlGenerate" targetRuntime="MyBatis3">
        <commentGenerator>
            <!-- 是否去除自动生成的注释 -->
            <property name="suppressAllComments" value="true"/>
        </commentGenerator>
        <!-- Mysql数据库连接的信息：驱动类、连接地址、用户名、密码 -->
        <jdbcConnection driverClass="com.mysql.cj.jdbc.Driver"
                        connectionURL="jdbc:mysql://192.168.236.135:3306/test?useUnicode=true;characterEncoding=utf-8;useJDBCCompliantTimezoneShift=true;serverTimezone=UTC"
                        userId="root"
                        password="123456">
        </jdbcConnection>
        <!-- Oracle数据库
            <jdbcConnection driverClass="oracle.jdbc.OracleDriver"
                connectionURL=""
                userId=""
                password="">
            </jdbcConnection>
        -->

        <!-- 默认为false，把JDBC DECIMAL 和NUMERIC类型解析为Integer，为true时把JDBC DECIMAL 和NUMERIC类型解析为java.math.BigDecimal -->
        <javaTypeResolver>
            <property name="forceBigDecimals" value="false"/>
        </javaTypeResolver>

        <!-- targetProject：生成POJO类的位置 -->
        <javaModelGenerator targetPackage="com.yese.pojo"
                            targetProject="./src/main/java">
            <!-- enableSubPackages:是否让schema作为包的后缀 -->
            <property name="enableSubPackages" value="false"/>
            <!-- 从数据库返回的值被清理前后的空格 -->
            <property name="trimStrings" value="true"/>
        </javaModelGenerator>

        <!-- targetProject：生成Mapper映射XML文件位置 -->
        <sqlMapGenerator targetPackage="mapper"
                         targetProject="./src/main/resources">
            <!-- enableSubPackages:是否让schema作为包的后缀 -->
            <property name="enableSubPackages" value="false"/>
        </sqlMapGenerator>

        <!-- targetProject：mapper接口生成的的位置 -->
        <javaClientGenerator type="XMLMAPPER" targetPackage="com.yese.mapper"
                             targetProject="./src/main/java">
            <!-- enableSubPackages:是否让schema作为包的后缀 -->
            <property name="enableSubPackages" value="false"/>
        </javaClientGenerator>

        <!-- 要生成哪些表-->
        <!-- tableName:要生成的表名, domainObjectName:生成后的实例名-->
        <table tableName="T_SYS_USER" domainObjectName="User"/>


    </context>
</generatorConfiguration>
```

```java
package com.yese.start;

import org.mybatis.generator.api.MyBatisGenerator;
import org.mybatis.generator.config.Configuration;
import org.mybatis.generator.config.xml.ConfigurationParser;
import org.mybatis.generator.internal.DefaultShellCallback;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class Generator {
    public void generator() throws Exception {
        List<String> warnings = new ArrayList<String>();
        boolean overwrite = true;
        /**指向逆向工程配置文件*/
        File configFile = new File("D:\\Java\\idea_workspace\\MyBatisGenerator\\src\\main\\resources\\generationConfig.xml");
        ConfigurationParser parser = new ConfigurationParser(warnings);
        Configuration config = parser.parseConfiguration(configFile);
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
                callback, warnings);
        myBatisGenerator.generate(null);
    }

    public static void main(String[] args) throws Exception {
        try {
            Generator generatorSqlmap = new Generator();
            generatorSqlmap.generator();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

运行main方法

![](https://studypic.oss-cn-shanghai.aliyuncs.com/pic/image-20191213221254272.png)

使用:

```java
//创建example对象
UserExample example = new UserExample();
//获取criteria
UserExample.Criteria criteria = example.createCriteria();
//设置条件
criteria.and...;
//调用userMapper的方法
List<User> users = userMapper.selectByExample(example);
		xxxMapper.selectByExample(example);
		.selectByPrimaryKey
		.select
		.selectCount
		.selectOne
		.insert();
		.insertSelective();
		.updateByPrimaryKey
		.updateByPrimaryKeySelective
		.deleteByPrimaryKey
		.deleteByExample

```

## 1.11.pageHelper


PageHelper.startPage方法重要提示

只有紧跟在PageHelper.startPage方法后的第一个Mybatis的查询（Select）方法会被分页。

请不要配置多个分页插件
请不要在系统中配置多个分页插件(使用Spring时,mybatis-config.xml和Spring<bean>配置方式，请选择其中一种，不要同时配置多个分页插件)！

分页插件不支持带有for update语句的分页
对于带有for update的sql，会抛出运行时异常，对于这样的sql建议手动分页，毕竟这样的sql需要重视。

分页插件不支持嵌套结果映射
由于嵌套结果方式会导致结果集被折叠，因此分页查询的结果在折叠后总数会减少，所以无法保证分页结果数量正确。

在Spring配置文件中

```xml
    <!-- 配置SqlSessionFactory -->
    <bean id="factory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <!-- 设置数据源 -->
        <property name="dataSource" ref="dataSource"></property>
        <!-- 别名包扫描,别名不区分大小写 --><!-- pojo的包名,多个用;隔开 -->
        <property name="typeAliasesPackage" value="com.yese.pojo"></property>

        <!--pageHelper-->
        <property name="plugins">
            <array>
                <bean class="com.github.pagehelper.PageInterceptor">
                    <property name="properties">
                        <!--使用下面的方式配置参数，一行配置一个,params=value1形式 -->
                        <value>
                            <!--helperDialect=mysql默认自动检测,可以手动指定-->
                            reasonable=true
                            supportMethodsArguments=true
                            params=count=countSql
                            autoRuntimeDialect=true<!--允许在运行时根据多数据源自动识别对应方言的分页-->
                        </value>
                    </property>
                </bean>
            </array>
        </property>
        
    </bean>
```



```java
//设置当前页和每页显示的条数
PageHelper.startPage(1, 5);
UserExample example = new UserExample();
UserExample.Criteria criteria = example.createCriteria();
criteria.andIdIsNotNull();
//调用dao查到list集合
List<User> users = userMapper.selectByExample(example);

//封装为PageInfo对象
PageInfo page = new PageInfo(users);
System.out.println("总数量：" + page.getTotal());
System.out.println("当前页查询记录：" + page.getList().size());
System.out.println("当前页码：" + page.getPageNum());
System.out.println("每页显示数量：" + page.getPageSize());
System.out.println("总页：" + page.getPages());

//直接返回PageInfo对象,分页所有的信息都包含在里面
return page;
```

## 1.12.其他知识

###### 延迟加载

只有在用到子对象的属性时才去嵌套查询数据

1.使用association标签的fetchType属性，该属性有lazy和eager两个值，分别代表延迟加载和积极加载。

2.MyBatis的全局配置中，有一个aggressiveLazyLoading参数，如果这个参数的值为ture，会使带有延迟加载属性的对象完整加载，如果为false，则会按需加载，这个参数默认值为ture（3.4.5版本开始默认值改为false）



###### MySQL自增返回

```xml
<!-- useGeneratedKeys:标识插入使用自增id
keyProperty:与useGeneratedKeys配套使用，用于绑定主键接收的pojo属性-->
<insert id="insertUserKey" parameterType="user" useGeneratedKeys="true" keyProperty="id">
	<!-- oracle等不支持id自增长的，可根据其id生成策略，先获取id 
    <selectKey resultType="int" order="BEFORE" keyProperty="id">
    	select seq_user_id.nextval as id from dual
    </selectKey> --> 
    
    <!-- mysql插入数据后，获取id -->
    <!-- selectKey:用于配置主键返回
	 		 keyProperty：要绑定的pojo属性
	 		 resultType:属性数据类型
	 		 order:指定什么时候执行，AFTER之后
	 -->
    <selectKey keyProperty="id" resultType="int" order="AFTER" >
		SELECT LAST_INSERT_ID()
    </selectKey>
		INSERT INTO USER (`id`,`username`,`password`,`phone`)
		VALUES (#{id},#{username},#{password},#{phone});
</insert>
```

###### MySQL的uuid返回主键

先在user类以及表中添加uuid2字段

```xml
<insert id="insertUserUUID" parameterType="user">
        <!-- selectKey:用于配置主键返回
             keyProperty：要绑定的pojo属性
             resultType:属性数据类型
             order:指定什么时候执行，BEFORE之前
        -->
        <selectKey keyProperty="uuid2" resultType="string" order="BEFORE">
            SELECT UUID()
        </selectKey>
    	INSERT INTO USER (`id`,`username`,`password`,`phone`,`uuid2`)
		VALUES (#{id},#{username},#{password},#{phone},#{uuid2});
</insert>
```



# 2.Spring

Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。

https://repo.spring.io/libs-release-local/org/springframework/spring/

开源免费,轻量级,非入侵式

SE/EE开发的一站式框架。一站式框架：有EE开发的每一层的解决方案。

解决企业应用开发的复杂性



spring框架以interface21框架为基础于2004/3/24发布了1.0版本

spring的理念:使现有的技术更加容易使用(本身是一个大杂烩),整合了现有的技术框架

作者:Rod Johnson

依赖:

```xml
<!--只需要引入这一个,会把其他模块也加进来-->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>5.2.2.RELEASE</version>
</dependency>
```



## 2.1.七大模块

![](https://studypic.oss-cn-shanghai.aliyuncs.com/pic/3c6dd4717e96d6610ff60a1aaf8cc170f47.jpg)

## 2.2.Spring 的核心功能

IOC:控制反转	DI依赖注入

AOP 面向切面编程

声明式事务

方便集成其他框架

## 2.3.IOC

IOC: Inversion of Control(控制反转)。对象由spring来创建,管理,装配

控制反转：将对象的创建权转交给Spring来管理

**IoC是一种设计思想，DI是实现IoC的一种方式**

程序不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低

没有IoC的程序中 , 使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给spring

**IoC是Spring框架的核心内容**，可以使用XML配置，使用注解，新版本的Spring也可以零配置实现IoC。



对象什么时候被创建?配置文件加载的时候,spring容器中管理的对象就已经被初始化了



Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。

![](https://studypic.oss-cn-shanghai.aliyuncs.com/pic/2003522015.png)

采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。

**控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。**



```java
package com.yese.pojo;

public class Hello {

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Hello{" +
                "name='" + name + '\'' +
                '}';
    }
}

```

applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--bean就是java对象 , 由Spring创建和管理-->
    <bean id="hello" class="com.yese.pojo.Hello">
        <!--property:属性 , value:值-->
        <property name="name" value="Spring"/>
    </bean>

</beans>
```

测试

```java
import com.yese.pojo.Hello;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
    public static void main(String[] args) {
        // 获取 spring 的上下文对象,解析applicationContext.xml文件 , 生成管理相应的Bean对象
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        // getBean : 参数即为spring配置文件中bean的id
        Hello hello = (Hello) context.getBean("hello");
        System.out.println(hello);
    }
}
```



## 2.4.DI

Dependency Injection,DI

依赖注入，前提必须有IOC的环境，Spring管理这个类的时候将类依赖的属性注入进来。

### 2.4.1.构造器注入

### 2.4.2.set方法注入[重点]

要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is 

### 2.4.3.拓展方式注入

P命名空间注入和c 命名空间注入

## 2.5.Bean的作用域

在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 .

```
scope：Bean的作用范围
	singleton	：默认，Spring会采用单例模式创建这个对象。
	prototype	：多例模式。每次请求都会创建一个新的 bean 实例
	request		：应用在web项目中，Spring创建这个类以后，将这个类存入到request范围中。
	session		：应用在web项目中，Spring创建这个类以后，将这个类存入到session范围中。
	globalsession：应用在web项目中，必须在porlet环境下使用。但是如果没有这种环境，相对于session。
```

## 2.6.Bean的自动装配

### 2.6.1.ByName

保证所有bean的id唯一,并且和自动注入的属性的set方法的值一致

### 2.6.2.ByType

保证所有bean的class唯一,并且类型和自动注入的属性的类型一致

## 2.7.注解实现自动装配

```xml
配置文件中开启属性注解支持！
<context:annotation-config/>
```

@Autowired是按类型自动转配的，不支持id匹配。
需要导入 spring-aop的包！

@Autowired注入的是接口,这里是多态的体现

Controller中:

```java
@Autowired
private UserService userService;
```

ServiceImpl中:

```java
@Autowired
private UserMapper userMapper;
```



## 2.8.Spring的工厂类

![](https://studypic.oss-cn-shanghai.aliyuncs.com/pic/image-20191117150923915.png)

###### BeanFactory

老版本的工厂类,调用getBean的时候，才会生成类的实例。

###### ApplicationContext

新版本的工厂类,加载配置文件的时候，就会将Spring管理的类都实例化。
ApplicationContext有两个实现类
1.ClassPathXmlApplicationContext	：加载类路径下的配置文件
2.FileSystemXmlApplicationContext	：加载文件系统下的配置文件

## 2.9.注解

**注解整理:**

https://mp.weixin.qq.com/s?__biz=MzIyMDQ4Mjg3Mw==&mid=2247490741&idx=1&sn=3a8d0fbdde40d3279c6683b6b34d66a8&chksm=97ca00e3a0bd89f573da1c409bc555767b8275fceb414c53b9cf0594746290f70fdd2c9f1b0e&mpshare=1&scene=24&srcid=#rd

###### IOC

```
写在实现类上
@Component:组件,修饰一个类,将这个类交给Spring管理.这个注解有三个衍生注解(功能类似),修饰类
	@Controller	：Web层
	@Service	：Service层
	@Repository ：Dao层
```

@Service注解是标注在实现类上的，因为@Service是把spring容器中的bean进行实例化，也就是等同于new操作，只有实现类是可以进行new实例化的，而接口则不能，所以是加在实现类上的。

###### DI

```
普通属性：@Value 从配置文件中获取值,如 @Value("${aa}")
对象属性：@Resource(按照名称完成属性注入), （这个注解属于J2EE的）
        @Autowired	：默认按类型注入(常用)
        @Qulifier	:按名称
@Nullable :表示这个属性可以为空
@Scope("singleton"):作用范围
```

## 2.10.注解开发

在spring4之后，想要使用注解形式，必须得要引入aop的包

引入context约束,增加注解支持

```xml
<!-- 组件扫描,配置扫描哪些包下的注解 -->
<context:component-scan base-package=""/>
```

## 2.11.小结

XML与注解比较

XML可以适用任何场景 ，结构清晰，维护方便
注解不是自己提供的类使用不了，开发简单方便
xml与注解整合开发 ：推荐最佳实践

xml管理Bean
注解完成属性注入
使用过程中， 可以不用扫描，扫描是为了类上的注解



```xml
<context:annotation-config/>  
```

作用：

进行注解驱动注册，从而使注解生效
用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册
如果不扫描包，就需要手动配置bean
如果不加注解驱动，则注入的值为null！

## 2.12.AOP

代理模式是SpringAOP的底层实现

动态代理分类:

- JDK的动态代理:只能对实现了接口的类产生代理

- Cglib的动态代理(类似于Javassist,第三方代理技术),可以对没有实现接口的类产生代理对象,生成子类对象

  

面向切面编程,通过预编译方式和运行期动态代理实现程序功能统一维护的一种技术

是OOP的扩展和延伸，用来解决OOP开发遇到的问题

在不修改源代码的情况下对程序进行增强(权限校验,日志记录,性能监控,事务控制)

在程序原有纵向执行流程中,针对某一个或某一些方法添加通知,形成横切面过程就叫做面向切面编程.

![](https://studypic.oss-cn-shanghai.aliyuncs.com/pic/1595583263.png)



AOP 在 spring 中的作用:

- 提供声明式事务
- 允许用户自定义切面

### 2.12.1.常用概念

● Aspect

表示切面。切入业务流程的一个独立模块。是一个类

● Advice

表示通知。是切面的具体实现方法。可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）和环绕通知（Around）五种。实现方法具体属于哪类通知，是在配置文件和注解中指定的。

● Target

表示被增强的对象

● Proxy

表示代理对象。将通知应用到目标对象之后被动态创建的对象。

● Join point

表示连接点。也就是业务流程在运行过程中需要插入切面的具体位置。

● Pointcut

表示切入点。用于定义通知应该切入到哪些连接点上，不同的通知通常需要切入到不同的连接点上。

● Weaving

表示切入，也称为织入。将切面应用到目标对象的过程。这个过程可以发生在编译期、类装载期及运行期。

### 2.12.2.在 spring 中实现 AOP

```xml
        <!--需要导入这个包-->
				<dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>1.9.5</version>
        </dependency>
```

原始的方法

```java
package com.yese.service;

public interface UserService {
    void insert();
    void update();
    void delete();
    void select();
}

```

```java
package com.yese.service.impl;

import com.yese.service.UserService;

public class UserServiceImpl implements UserService {
    public void insert() {
        System.out.println("添加了一个用户");
    }
    public void update() {
        System.out.println("修改了一个用户");
    }
    public void delete() {
        System.out.println("删除了一个用户");
    }
    public void select() {
        System.out.println("查询了一个用户");
    }
}

```

```java
import com.yese.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        // 动态代理的是接口
        UserService userService = (UserService) context.getBean("userService");
        userService.insert();
        System.out.println("--------------------------");
        userService.update();
        System.out.println("--------------------------");
        userService.delete();
        System.out.println("--------------------------");
        userService.select();
    }
}

```



#### 2.12.2.1.实现 spring 的接口

```java
package com.yese.advice;

import org.springframework.aop.MethodBeforeAdvice;

import java.lang.reflect.Method;

/**
 * 前置通知:实现MethodBeforeAdvice
 * 在目标方法调用之前执行。
 */
public class BeforeLog implements MethodBeforeAdvice {
    /**
     * @param method 要执行的目标对象的方法
     * @param args   参数
     * @param target 目标对象
     * @throws Throwable
     */
    public void before(Method method, Object[] args, Object target) throws Throwable {
        System.out.println("方式 1的前置通知被执行了");
    }
}

```

```java
package com.yese.advice;

import org.springframework.aop.AfterReturningAdvice;

import java.lang.reflect.Method;

/**
 * 后置通知:实现AfterReturningAdvice
 * 在目标方法调用之后执行。
 */
public class AfterLog implements AfterReturningAdvice {

    /**
     *
     * @param returnValue 返回结果
     * @param method 要执行的目标对象的方法
     * @param args 参数
     * @param target 目标对象
     * @throws Throwable
     */
    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
        System.out.println("方式 1的后置通知被执行了");
    }
}

```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <!--xml 方式注册bean,实际上完全可以使用注解的方式来注册-->
    <bean id="userService" class="com.yese.service.impl.UserServiceImpl"/>

    <!--方式 1:实现 spring 的接口,更强大-->
    <bean id="beforeLog" class="com.yese.advice.BeforeLog"/>
    <bean id="afterLog" class="com.yese.advice.AfterLog"/>
    <aop:config>
        <!--切入点   expression表达式:要执行的位置-->
        <aop:pointcut expression="execution(* com.yese.service.*.*(..))" id="mypoint1"/>
        <!--在切入点上执行前置通知-->
        <aop:advisor advice-ref="beforeLog" pointcut-ref="mypoint1"/>
        <!--在切入点上执行后置通知-->
        <aop:advisor advice-ref="afterLog" pointcut-ref="mypoint1"/>
    </aop:config>
</beans>
```



#### 2.12.2.2.自定义类

```java
package com.yese.diy;

/**
 * 方式 2:自定义类
 */
public class DiyPointCut {

    public void before() {
        System.out.println("方式 2的前置通知被执行了");
    }
    
    public void after() {
        System.out.println("方式 2的后置通知被执行了");
    }
}

```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <!--xml 方式注册bean,实际上完全可以使用注解的方式来注册-->
    <bean id="userService" class="com.yese.service.impl.UserServiceImpl"/>

    <!--方式 2:自定义类-->
    <bean id="diyPointCut" class="com.yese.diy.DiyPointCut"/>
    <aop:config>
        <!--自定义切面,ref:要引用的类,即定义的类-->
        <aop:aspect ref="diyPointCut">
            <!--切入点-->
            <aop:pointcut expression="execution(* com.yese.service.*.*(..))" id="mypoint2"/>
            <!--前置通知-->
            <aop:before method="before" pointcut-ref="mypoint2"/>
            <!--后置通知-->
            <aop:after method="after" pointcut-ref="mypoint2"/>
        </aop:aspect>
    </aop:config>

</beans>
```

#### 2.12.2.3.注解方式

```java
package com.yese.diy;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

/**
 * 方式 3:注解
 */
//@Aspect:标注该类为切面
@Aspect
public class AnnotationPointCut {

    @Before("execution(* com.yese.service.*.*(..))")
    public void before() {
        System.out.println("方式 3的前置通知被执行了");
    }

    @After("execution(* com.yese.service.*.*(..))")
    public void after() {
        System.out.println("方式 3的后置通知被执行了");
    }

    // 环绕通知
    @Around("execution(* com.yese.service.*.*(..))")
    public void around(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("方式 3的环绕通知环绕前被执行了");
        joinPoint.proceed();
        System.out.println("方式 3的环绕通知环绕后被执行了");
    }
}

```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <!--xml 方式注册bean,实际上完全可以使用注解的方式来注册-->
    <bean id="userService" class="com.yese.service.impl.UserServiceImpl"/>

    <!--方式 3:注解-->
    <bean id="anotationPointCut" class="com.yese.diy.AnnotationPointCut"/>
    <!--开启 aop 注解支持-->
    <aop:aspectj-autoproxy/>
</beans>
```



## 2.13.声明式事务

### 2.13.1.事务Transaction

指一组操作，里面包含多个单一的逻辑。只要有一个逻辑没有执行成功，那么都算失败。 所有的数据都回归到最初的状态(回滚)

事务是为了确保逻辑的成功。 例子： 银行转账。 

### 2.13.2.事务的特性ACID

* 原子性:事务中包含的逻辑，不可分割

* 一致性:事务执行前后数据的完整性

* 隔离性:事务在执行期间不应该受到其他事务的影响

* 持久性:事务执行成功，那么数据应该持久保存到磁盘上

### 2.13.3.spring 的事务管理

- 声明式事务:AOP 的应用,不用修改原有的代码
- 编程式事务:需要在代码中进行事务的管理(手动 try-catch)





## 2.14.新特性

基于Java类进行配置

JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。



编写一个实体类，Dog

```java
@Component  //将这个类标注为Spring的一个组件，放到容器中！
public class Dog {
    public String name = "小黑";
}
```


新建一个config配置包，编写一个MyConfig配置类

```java
@Configuration  //代表这是一个配置类
  public class MyConfig {
    
  @Bean //通过方法来注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！
  public Dog dog(){
      return new Dog();
  }
    
}
```


测试

```java
@Test
public void test(){
    ApplicationContext context =
            new AnnotationConfigApplicationContext(MyConfig.class);
    Dog dog = (Dog) context.getBean("dog");
    System.out.println(dog.name);
}
```


成功输出结果！

关于这种Java类的配置方式，在SpringBoot 和 SpringCloud中会大量使用



# 3.SpringMVC

SpringMVC是当前最优秀的MVC框架

SpringMVC 容器是Spring 容器的子容器. SpringMVC 容器中能够调用 Spring 容器的所有内容.

MVC:是一种软件设计规范

- 模型(model)
- 视图(view)
- 控制器(controller)

## 3.1.重要组件

- DispatcherServlet : 前端控制器,接收所有请求分发到不同的 controller.核心
- HandlerMapping: 处理器映射器:解析请求格式.判断要执行哪个具体的方法.
- HandlerAdapter: 处理器适配器:负责调用具体的方法.
- ViewResovler:视图解析器.解析结果,准备跳转到具体的物理视图

## 3.2.运行原理

```
如果在web.xml中设置DispatcherServlet的<url-pattern>为/时,当客户端发起请求,请求一个控制器,首先会执行DispatcherServlet.由DispatcherServlet调用HandlerMapping的DefaultAnnotationHandlerMapping解析URL,解析后调用HandlerAdatper组件的AnnotationMethodHandlerAdapter调用Controller中的HandlerMethod.当HandlerMethod执行完成后会返回ModelAndView给DispatcherServlet,ModelAndView会被ViewResovler进行视图解析,解析后把页面响应给客户端.
```



![](https://studypic.oss-cn-shanghai.aliyuncs.com/pic/Snipaste_2020-03-24_22-32-29.png)

## 3.3.controller

@Controller

如果是@Restcontroller则不会走视图解析器,会直接返回json 数据



## 3.4.@RequestMapping

1.路径映射可以是数组

```java
@RequestMapping(value = {"/test1", "/test2"})
```

2.@RequestMapping可以加在controller的上面，用于目录分级管理

3.限定请求方法

```java
@RequestMapping(value = {"/test"}, method = {RequestMethod.GET, RequestMethod.POST})
或者直接使用@GetMapping/@PostMapping
```



## 3.5.RestFul风格

https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486441&idx=1&sn=2b675b6e62215aa2f4d0bbf8e38baf2b&chksm=cea24422f9d5cd34fbdef3351ba9918faa091ba821364163b9e201721d5e16d9956e2c2eb5ab&mpshare=1&scene=24&srcid=&sharer_sharetime=1585064760223&sharer_shareid=77789d764b86b768aa16865091e9b882#rd

Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可

以更简洁，更有层次，更易于实现缓存等机制。

也比较安全

![](https://studypic.oss-cn-shanghai.aliyuncs.com/pic/image-20191218220721975.png)

在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。

方法级别的注解变体有如下几个： 组合注解

@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@PatchMapping

```java
    @RequestMapping("/test/{aa}/{bb}")
    public void test(@PathVariable("aa") String aa,@PathVariable("bb") String bb) {
        System.out.println(aa);
        System.out.println(bb);
    }
```

@PathVariable("")的作用:将请求路径上的{**xxx**}内的参数映射到方法的入参上



## 3.6.参数绑定

### 默认支持的参数类型

默认类型会自动绑定

HttpServletRequest request

HttpServletResponse response

HttpSession session

Model model	  (model.addAttribute("", "");)

ModelMap modelMap

### 简单数据类型

整型、字符串、日期、单精度/双精度、布尔型

(使用包装类)



名称一致时,直接映射(即使一直也建议使用@RequestParam注解)

 http://localhost:8080/test?loginName=zhangsan&loginPassword=1 

```java
@RequestMapping("/test")
public void test(String loginName, String loginPassword) {
    System.out.println(loginName + "----" + loginPassword);
}
```


名称不一致时,使用@RequestParam注解

value:传入的参数名，required：是否必填 默认是true ,defaultValue:默认值

如果RequestParam没有除了value的其他值,可以简写为@RequestParam("")

 http://localhost:8080/test?name=zhangsan&pwd=1 

```java
@RequestMapping("/test")
public void test(@RequestParam(value = "name", required = true, defaultValue = "zhangsan") String loginName, @RequestParam(value = "pwd", required = true, defaultValue = "1") String loginPassword) {
    System.out.println(loginName + "----" + loginPassword);
}
```
### pojo类型

表单的name属性必需与pojo的属性名称一致。

```jsp
<input type="text" name="username"/> 
<input type="text" name="loginName"/> 
<input type="text" name="loginPassword"/>
```



```java
@RequestMapping("/test")
public void test(User user) {
    System.out.println(user);
}
```
### 包装的pojo

对象.属性格式的参数

```jsp
<input type="text" name="user.username"/> 
<input type="text" name="user.loginName"/> 
<input type="text" name="user.loginPassword"/>
```

```java
public class QueryVo {
	private User user;
}
```

```java
@RequestMapping("/test")
public void test(QueryVo vo) {
    System.out.println(vo);
}
```

### 多个同名参数



### 集合对象类型



### Restful 方式

RESTful风格url上的参数通过{}占位符绑定

## 3.7.返回值类型

### String

应用场景1：直接返回视图名称

放在 WEB-INF文件夹下的页面没有办法通过地址栏直接访问，只能通过后台的跳转来间接的访问

```java
//已配置视图解析器
@RequestMapping("/toUserEditJsp") 
public String toUserEditJsp() { 	
    return "userEdit"; 
} 
```

应用场景2：返回 含有 redirect 或 forward 标签的字符串

/后面表示的是请求的方法而不是jsp的简写

```java
// 登录成功，重定向到主页面
return "redirect:/main"; 

// 登录失败，转发到登录页面
return "forward:/login";
```

注意：如果在返回的字符串前加上了 redirect 或者 forward 标签，就不会走视图解析器，而是直接转发或重定向到指定的路径，所以对于重定向标签后面就不能加 WEB-INF ，因为重定向是客户端重新发送的请求，WEB-INF 目录下的页面仍然访问不到，但是对于转发标签的话后面可以跟 WEB-INF。

 注意：如果方法声明了注解@ResponseBody ，则会直接将返回值输出到页面。 

### Json

常见的 List 集合、Map，实体类等都可以返回,一定要加@ResponseBody注解

@RequestBody用于接收用户传入json串转成pojo  

@ResponseBody把pojo转成json串响应用户  

```java
@RequestMapping("/user") 
@ResponseBody
public User getUser() {
  User user = new User();
  return user;
}

@RequestMapping("/users") 
@ResponseBody
public List<User> getALlUser() {
  List<User> users = new ArrayList<>();
  return users;
}
```

```java
@RequestMapping("getUser")
@ResponseBody
public User getUser(@RequestBody User user1) {
    System.out.println("接收到的json用户数据为：" + user1);
    User user2 = new User();
    return user2;
}
```



### ModelAndView

应用场景：其实这种返回值的应用场景比较随意，既可以用来做页面的跳转，也可以在跳转到页面的时候携带一些数据

```java
@RequestMapping("/getUserList")
public ModelAndView getUserList() {
	ModelAndView mav = new ModelAndView();//创建一个modelAndView对象
	
	List<User> users = new ArrayList<User>();
	users.add(user1);
	users.add(user2);
	users.add(user3);
	// 将数据放入modelAndView对象
	mav.addObject("users", users);
	// 将返回的逻辑视图名称放入modelAndView对象
	mav.setViewName("userList");
	return modelAndView;
}
```
### void

如果是返回 void ，就必须要在方法的参数中添加 HttpServletRequest 和 HttpServletResponse 来进行页面的跳转

```java
public void test(HttpServletRequest request, HttpServletResponse response) {
	// 转发到指定页面
	request.getRequestDispatcher("xxx").forward(request, response);
	// 或者重定向到指定页面
	response.sendRedirect("/xxx");
}
```



## 3.8.转发和重定向

有视图解析器的情况下

```java
@Controller
public class controller1 {
    @RequestMapping("/test1/t1")
    public String test1(){
        //转发
        return "test";
    }

    @RequestMapping("/test2/t2")
    public String test2(){
        //重定向
        return "redirect:/index.jsp";//加了redirect就不会走视图解析器
        //return "redirect:hello"; //hello为另一个请求
    }

}
```

无视图解析器

```java
@Controller
public class controller2 {
    @RequestMapping("/test1/t1")
    public String test1(){
        //转发
        return "/index.jsp";
    }

    @RequestMapping("/test2/t2")
    public String test2(){
        //转发二
        return "forward:/index.jsp";
    }

    @RequestMapping("/test3/t3")
    public String test3(){
        //重定向
        return "redirect:/index.jsp";
    }
}
```



## 3.9.全局异常处理器

![](https://studypic.oss-cn-shanghai.aliyuncs.com/pic/20190305172247584.png)

###### 创建全局异常处理器

```java
package com.yese.exception;

import org.springframework.web.servlet.HandlerExceptionResolver;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.PrintWriter;
import java.io.StringWriter;


/**
 * 全局异常处理器
 *
 * @author zqf
 */
public class GlobalExceptionResolver implements HandlerExceptionResolver {

    @Override
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception e) {
        // 向控制台上打印堆栈信息
        e.printStackTrace();

        //错误消息
        String msg = "很抱歉,系统异常,请联系管理员!";
        // 判断异常的种类
        if (e instanceof UserException) {
            // 如果是自定义异常，就从异常里面取出错误消息
            msg = ((UserException) e).getMsg();
        } else {
            // 如果是运行时异常，则取错误的堆栈信息
            StringWriter s = new StringWriter();
            PrintWriter printWriter = new PrintWriter(s);
            e.printStackTrace(printWriter);
            msg = s.toString();
        }

        // 写日志、发短信、发邮件
        // 在此省略这一步......

        // 返回一个友好的错误页面，并显示错误消息
        ModelAndView mav = new ModelAndView();
        mav.addObject("msg", msg);
        mav.setViewName("error");
        return mav;
    }
}
```

###### 配置全局异常处理器

springmvc.xml中

```xml
<!-- 配置全局异常处理器，且全局异常处理器只能有一个 --><bean class="com.yese.exception.GlobalExceptionResolver"></bean>
```

###### 自定义异常类

```java
package com.yese.exception;

/**
 * 自定义user异常
 *
 * @author zqf
 */
public class UserException extends Exception {

    //错误消息
    private String msg;

    public UserException() {
        super();
    }

    public UserException(String msg) {
        super();
        this.msg = msg;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }
}
```

###### error页面

在/WEB-INF/jsp目录下提供一个错误页面——error.jsp

```jsp
<h1>很抱歉,系统异常,请联系管理员!</h1>
<span>错误消息:${msg}</span>
```

###### 测试

```java
@RequestMapping("/test")
public void test() {
    int a = 100 / 0;
    //throw new UserException("自定义的异常:用户不存在!");
}
```

## 3.10.拦截器

Spring MVC中的拦截器（Interceptor）类似于Servlet中的过滤器（Filter），它主要用于拦截用户请求并作相应的处理。例如通过拦截器可以进行权限验证、记录请求信息的日志、判断用户是否登录等。要使用Spring MVC中的拦截器，就需要对拦截器类进行定义和配置。通常拦截器类可以通过两种方式来定义。

1.通过实现HandlerInterceptor接口，或继承HandlerInterceptor接口的实现类（如andlerInterceptorAdapter）来定义。

2.通过实现WebRequestInterceptor接口，或继承WebRequestInterceptor接口的实现类来定义。

###### 创建拦截器

```java
package com.yese.interceptor;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


/**
 * 自定义拦截器
 *
 * @author zqf
 */
public class MyInterceptor1 implements HandlerInterceptor {

    //在Controller方法执行前被执行,其返回值表示是否中断后续操作。当其返回值为true时，表示继续向下执行.当其返回值为false时，会中断后续的所有操作（包括调用下一个拦截器和控制器类中的方法执行等）
    //登录拦截、权限认证等等
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("preHandle第一个执行");

        //返回true放行，false拦截
        return false;
    }

    //在Controller方法执行后，返回ModelAndView之前被执行
    //对请求域中的模型和视图做出进一步的修改
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle第二个执行");

    }

    //整个请求完成，即视图渲染结束之后执行
    //处理异常、记录日志、资源清理
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion第三个执行");

    }
}
```

###### 配置拦截器

springmvc.xml中配置

```xml
    <!-- 配置拦截器 -->
    <mvc:interceptors>
        <!--全局拦截器，拦截所有的请求-->
        <!--<bean class="com.yese.interceptor.MyInterceptor"/>-->

        <!-- 定义拦截器1 -->
        <mvc:interceptor>
            <!-- 配置拦截器的作用路径, path配置</**>拦截所有请求，包括二级以上目录，</*>拦截所有请求，不包括二级以上目录 -->
            <mvc:mapping path="/**"/><!-- 可以配置多个 -->
            <!--不需要拦截的路径-->
            <mvc:exclude-mapping path=""/><!-- 可以配置多个 -->
            <bean class="com.yese.interceptor.MyInterceptor1"/>
        </mvc:interceptor>
    </mvc:interceptors>
```

注意:

```
<mvc:interceptors>元素用于配置一组拦截器，基子元素<bean>中定义的是全局拦截器，它会拦截所有的请求；而<mvc:interceptor>元素中定义的是指定路径的拦截器，它会对指定路径下的请求生效。<mvc:interceptor>元素的子元素<mvc:mapping>用于配置拦截器作用的路径，该路径在其属性path 中定义。如上述代码中 path 的属性值“/**” 表示拦截所有路径，“/hello” 表示拦截所有以 “/hello” 结尾的路径。如果在请求路径中包含不需要拦截的内容，还可以通过<mvc:exclude-mapping>元素进行配置。
注意：<mvc:interceptor>中的子元素必须按照上述代码中的配置顺序进行编写，即<mvc:mapping> <mvc:exclude-mapping> <bean>，否则文件会报错。
```

###### 多个拦截器的执行流程

多个拦截器（假设有两个拦截器Interceptor1和Interceptor2，并且在配置文件中， Interceptor1拦截器配置在前），在程序中的执行流程如下图所示：

![](https://studypic.oss-cn-shanghai.aliyuncs.com/pic/1240732-20171114200511874-738520900.png)

###### 拦截器与过滤器的区别

①拦截器是基于Java的反射机制，而过滤器是基于函数回调。

②拦截器不依赖servlet容器，过滤器依赖servlet容器。

③拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。

④拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。

⑤在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。

⑥拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。

###### 对 Date  类型的转换


















